#include<stdio.h>
#include<string.h>
#include<ctype.h>
#include<windows.h>
enum { BLACK=0, BLUE, GREEN, CYAN, RED, MAGENTA, BROWN, LIGHTGRAY,
        DARKGRAY, LIGHTBLUE, LIGHTGREEN, LIGHTCYAN, LIGHTRED, LIGHTMAGENTA, YELLOW, WHITE, };
static short __BACKGROUND = 0;
static short __FOREGROUND = 0;
void textbackground(short color) {
	__BACKGROUND = color;
	HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
	SetConsoleTextAttribute(hOut, __FOREGROUND + (color << 4));
}
void textcolor(short color) {
	__FOREGROUND = color;
	HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
	SetConsoleTextAttribute(hOut, color + (__BACKGROUND << 4));
}
void gotoxy(short c, short r) {
	if (c>0 && r>0) {
		COORD CursorPosition = { c-1, r-1 };
		HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
		SetConsoleCursorPosition(hOut, CursorPosition);
	}
}
char * spazi(char * str)    // togliere eventuali spazi da una stringa
{
	int k, l=0;
	for(k=0; str[k]!='\0'; k++){
	    if(!isblank(str[k]) && !ispunct(str[k]) && !isdigit(str[k])){
	        str[k]=toupper(str[k]);
	        str[l++]=str[k];
	    }
    }
	str[l]='\0';
	return str;
}
void assegamento_posizioni(char str[100+1], int pos[100+1])
{
	int cont[26], i, k, j;
	for(i=0; i<26; i++)        
	    cont[i]=i;           // alla variabile cont[i] assegno il valore della propria posizione, i, fino a 26
	i=0;                     // ad ogni posizione dell'array cont assegno il valore della propria posizione, i, fino a 26 in modo tale che posso, in seguito, controllare l'array str
	j=1;
	while(i<26){
		for(k=0; str[k]!='\0'; k++){
			if(cont[i]==str[k]-'A'){    
	       	    pos[k]=j;      // assegno all'array pos, nella posizione k, un valore che corrisponde all'ordine alfabetico del carattere nella stringa str, cioè nella parola chiave;
	       	    j++;           // k corrisponde alla posizione del carattere nella stringa str.
	        }
		}
		i++;
	}
}
void numeri_corrispondenti(int len, int pos[100+1])
{
	textbackground(0);
	textcolor(10);
	int k;
	for(k=0; k<len-1; k++){
		if(k<len-2){
			printf("%u-", pos[k]);
		}
		else{
			printf("%u", pos[k]);
		}
	}
}
void parola_tabella(char str[100+1], int len)
{
	textcolor(CYAN);
	textbackground(0);
	int k;
	for(k=0; k<len-1; k++)
		printf("  %c  ", str[k]);
}
void lineette_tabella(unsigned len)           //visualizza riga di lineette tabella        
{
	unsigned k;
	textcolor(6);
	for(k=0; k<len-1; k++){
		printf("  -  ");
	}
}
void numeri_corrispondenti_tabella(int len, int pos[100+1])
{
	textcolor(10);
	int k;
	for(k=0; k<len-1; k++){                  
		if(pos[k]<10)
	   		printf("  %u  ", pos[k]);
	   	else
	      	printf("  %u ", pos[k]);
	}
}
void frase_tabella(char str2[100+1], char matrice[100+1][100+1], int len)
{
	textcolor(RED);
	int k, r=0, c=0;
	for(k=0; str2[k]!='\0' && str2[k]!='\n'; k++){             //visualizza messaggio in fase di crittografia tabella
		matrice[r][c]=str2[k];
		printf("  %c  ", matrice[r][c]);
		c++;
		if(c==len-1){
			printf("\n");
			c=0;
			r++;
		}
	}
}
void lettere_casuali(char matrice[100+1][100+1], int len, int len2)
{
	textcolor(6);
	int r, c;
	r=(len2-1)/(len-1);
	for(c=(len2-1)%(len-1); c<len-1 && c!=0; c++){
		matrice[r][c]=(char) 65+rand()%26;
		printf("  %c  ", matrice[r][c]);
	}
}
void messaggio_crittografato(char matrice[100+1][100+1], int pos[100+1], int len, int len2)
{
	textbackground(0);	
    int c=0, r=0, j=1, k;
	k=(len2-1)/(len-1);
	while(j<len){
		if(pos[c]==j){
			for(r=0; r<=k; r++){
				if(r==(len2-1)/(len-1) && c>=(len2-1)%(len-1)){
					textcolor(6);
				}
				else{
					textcolor(RED);
				}
				printf("%c", matrice[r][c]);
			}
			j++;
			c=0;
			printf("  ");
		}
		else
			c++;
	}
}
int main()
{
	char str[100+1], str2[100+1];
	unsigned t;
		textcolor(WHITE);
		textbackground(1);
	printf("INSERISCI UNA SINGOLA PAROLA COME CHIAVE CRITTOGRAFICA:\n");
		textcolor(CYAN);
		textbackground(0);
	fgets(str, sizeof(str), stdin);
		textcolor(WHITE);
		textbackground(1);
	printf("INSERISCI IL MESSAGGIO DA CRITTOGRAFARE:\n");
		textcolor(RED);
		textbackground(0);
	fgets(str2, sizeof(str2), stdin);
		textcolor(WHITE);
		textbackground(1);
	printf("SELEZIONA TIPOLOGIA DI ESERCIZIO(1-2):\n");
	    textcolor(9);
	    textbackground(0);
	printf("1)CIFRARIO A TRASPOSIZIONE REGOLARE: nella tabella, le posizioni vuote alla fine dell'ultima riga vengono riempite\n  con caratteri alfabetici casuali;\n");
	printf("2)CIFRARIO A TRASPOSIZIONE IRREGOLARE: nella tabella, le posizioni vuote alla fine dell'ultima riga rimangono vuote.\n");
		textcolor(WHITE);
	scanf("%u", &t);
	
	spazi(str);                            // eliminare spazi, segni, numeri, lettere tutte maiuscole
	spazi(str2);
	int len=strlen(str);
	int pos[100+1]; 
	int len2=strlen(str2);
	char matrice[100+1][100+1];            // assegno all'array pos, nella posizione k, un valore che corrisponde all'ordine alfabetico del carattere nella stringa str, cioè nella parola chiave;
	assegamento_posizioni(str, pos);      // k corrisponde alla posizione del carattere nella stringa str.
	
	textcolor(WHITE);
	textbackground(1);
	printf("NUMERI CORRISPONDENTI:\n");       //visualizza numeri corrispondenti
    numeri_corrispondenti(len, pos);
	printf("\n");
	
	textcolor(WHITE);
	textbackground(1);
	printf("TABELLA:\n\n");
	
	parola_tabella(str, len);
	printf("\n");                                   //visualizza lettere parola tabella
	
	lineette_tabella(len);                         //visualizza riga di lineette tabella
	printf("\n");
    
    numeri_corrispondenti_tabella(len, pos);       //visualizza numeri corrispondenti tabella
	printf("\n");
	
	lineette_tabella(len);                   //visualizza riga di lineette tabella
	printf("\n");
	
	
	
	frase_tabella(str2, matrice, len);           //visualizza messaggio in fase di crittografia tabella
	
	if(t==1){
		lettere_casuali(matrice, len, len2);
    }
	printf("\n\n");
	
	textcolor(WHITE);
	textbackground(1);
	printf("MESSAGGIO CRITTOGRAFATO: \n");
	messaggio_crittografato(matrice, pos, len, len2);
	
	textcolor(WHITE);
}
